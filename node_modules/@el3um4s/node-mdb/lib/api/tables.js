"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.table = void 0;
const path = require("path");
const fs = __importStar(require("fs/promises"));
const run_vbs_1 = require("@el3um4s/run-vbs");
const decode_mdb_strange_chars_1 = require("@el3um4s/decode-mdb-strange-chars");
const api_schema_1 = require("../vbs/api_schema");
const api_schema_table_1 = require("../vbs/api_schema_table");
const api_query_all_values_1 = require("../vbs/api_query_all_values");
const api_sql_1 = require("../vbs/api_sql");
const list = async (data) => {
    const vbs = api_schema_1.api_schema;
    const file = path.resolve(data.database);
    const result = await (0, run_vbs_1.runVbsBuffer)({
        vbs,
        args: [file, "JSON"],
    });
    const resultDecoded = (0, decode_mdb_strange_chars_1.decodeVBSBuffer)(result);
    const obj = JSON.parse(resultDecoded);
    const onlyTables = obj.result
        .filter((x) => x.TABLE_TYPE.toLowerCase() === "table")
        .map((x) => x.TABLE_NAME);
    return onlyTables;
};
const listToFile = async (data) => {
    const result = await list({ database: data.database });
    const r = result.join("\n");
    const file = path.resolve(data.file);
    await fs.writeFile(file, r);
    return true;
};
const all = async (data) => {
    const vbs = api_schema_1.api_schema;
    const file = path.resolve(data.database);
    const result = await (0, run_vbs_1.runVbsBuffer)({
        vbs,
        args: [file, "JSON"],
    });
    const resultDecoded = (0, decode_mdb_strange_chars_1.decodeVBSBuffer)(result);
    const obj = JSON.parse(resultDecoded);
    const onlyTables = obj.result
        .filter((x) => x.TABLE_TYPE.toLowerCase() === "table" ||
        x.TABLE_TYPE.toLowerCase() === "system table" ||
        x.TABLE_TYPE.toLowerCase() === "access table")
        .map((x) => x.TABLE_NAME);
    return onlyTables;
};
const system = async (data) => {
    const vbs = api_schema_1.api_schema;
    const file = path.resolve(data.database);
    const result = await (0, run_vbs_1.runVbsBuffer)({
        vbs,
        args: [file, "JSON"],
    });
    const resultDecoded = (0, decode_mdb_strange_chars_1.decodeVBSBuffer)(result);
    const obj = JSON.parse(resultDecoded);
    const onlyTables = obj.result
        .filter((x) => x.TABLE_TYPE.toLowerCase() === "system table" ||
        x.TABLE_TYPE.toLowerCase() === "access table")
        .map((x) => x.TABLE_NAME);
    return onlyTables;
};
const schema = async (data) => {
    const vbs = api_schema_table_1.api_schema_table;
    const file = path.resolve(data.database);
    const result = await (0, run_vbs_1.runVbsBuffer)({
        vbs,
        args: [file, `"${data.table}"`, "JSON"],
    });
    const resultDecoded = (0, decode_mdb_strange_chars_1.decodeVBSBuffer)(result);
    const obj = JSON.parse(resultDecoded);
    return obj.result;
};
const read = async (data) => {
    const vbs = api_query_all_values_1.api_query_all_values;
    const file = path.resolve(data.database);
    const result = await (0, run_vbs_1.runVbsBuffer)({
        vbs,
        args: [file, `"${data.table}"`, "JSON"],
    });
    const resultDecoded = (0, decode_mdb_strange_chars_1.decodeVBSBuffer)(result);
    const obj = JSON.parse(resultDecoded);
    return obj.result;
};
const exportToFileJSON = async (data) => {
    const result = await read({ database: data.database, table: data.table });
    const file = path.resolve(data.file);
    await fs.writeFile(file, JSON.stringify(result));
    return true;
};
const exportToFileCSV = async (data) => {
    const vbs = api_query_all_values_1.api_query_all_values;
    const mdb = path.resolve(data.database);
    const result = await (0, run_vbs_1.runVbsBuffer)({
        vbs,
        args: [mdb, `"${data.table}"`, "CSV"],
    });
    const resultDecoded = (0, decode_mdb_strange_chars_1.decodeVBSBuffer)(result).trim();
    const file = path.resolve(data.file);
    await fs.writeFile(file, resultDecoded);
    return true;
};
const count = async (data) => {
    const vbs = api_sql_1.api_sql;
    const file = path.resolve(data.database);
    const result = await (0, run_vbs_1.runVbsBuffer)({
        vbs,
        args: [file, `"SELECT COUNT(*) AS RESULT FROM [${data.table}]"`, "JSON"],
    });
    const resultDecoded = (0, decode_mdb_strange_chars_1.decodeVBSBuffer)(result);
    const obj = JSON.parse(resultDecoded);
    return parseInt(obj.result[0].RESULT);
};
const select = async (data) => {
    const vbs = api_sql_1.api_sql;
    const file = path.resolve(data.database);
    const listColumns = data.columns
        ? data.columns.map((x) => `[${x}]`).join(",")
        : "*";
    const where = data.where
        ? ` WHERE ${data.where
            .replaceAll("\r\n", "\n")
            .replaceAll("\n", " ")
            .replaceAll('"', "'")}`
        : "";
    const result = await (0, run_vbs_1.runVbsBuffer)({
        vbs,
        args: [
            file,
            `"SELECT ${listColumns} FROM [${data.table}] ${where} "`,
            "JSON",
        ],
    });
    const resultDecoded = (0, decode_mdb_strange_chars_1.decodeVBSBuffer)(result);
    const obj = JSON.parse(resultDecoded);
    return obj.result;
};
const readAllTables = async (data) => {
    const { database, events } = data;
    const tables = await list({ database });
    if (events?.onStart) {
        events.onStart(tables);
    }
    const result = await Promise.all(tables.map(async (table) => {
        const rows = await count({ database, table });
        const content = await read({ database, table });
        const result = {
            TABLE_NAME: table,
            TABLE_CONTENT: content,
            TABLE_ROWS: rows,
        };
        if (events?.onTableRead) {
            events?.onTableRead(result);
        }
        return result;
    }));
    if (events?.onEnd) {
        events.onEnd(result);
    }
    return result;
};
const exportAllTablesToFileJSON = async (data) => {
    const { database, folder, events } = data;
    const tables = await list({ database });
    if (events?.onStart) {
        events.onStart(tables);
    }
    try {
        await fs.access(path.resolve(folder));
    }
    catch {
        await fs.mkdir(path.resolve(folder));
    }
    const result = await Promise.all(tables.map(async (table) => {
        const rows = await count({ database, table });
        const content = await read({ database, table });
        const result = {
            TABLE_NAME: table,
            TABLE_CONTENT: content,
            TABLE_ROWS: rows,
        };
        const fileJSON = path.resolve(folder, `${table}.json`);
        await fs.writeFile(fileJSON, JSON.stringify(result.TABLE_CONTENT));
        if (events?.onTableRead) {
            events?.onTableRead(result);
        }
        return result;
    }));
    if (events?.onEnd) {
        events.onEnd(result);
    }
    return true;
};
const exportAllTablesToFileCSV = async (data) => {
    const { database, folder, events } = data;
    const tables = await list({ database });
    if (events?.onStart) {
        events.onStart(tables);
    }
    try {
        await fs.access(path.resolve(folder));
    }
    catch {
        await fs.mkdir(path.resolve(folder));
    }
    const returnResult = events?.onTableRead || events?.onEnd;
    const result = await Promise.all(tables.map(async (table) => {
        const file = path.resolve(folder, `${table}.csv`);
        await exportToFileCSV({ database, table, file });
        if (returnResult) {
            const rows = await count({ database, table });
            const content = await read({ database, table });
            const result = {
                TABLE_NAME: table,
                TABLE_CONTENT: content,
                TABLE_ROWS: rows,
            };
            if (events?.onTableRead) {
                events?.onTableRead(result);
            }
            return result;
        }
        return {
            TABLE_NAME: table,
            TABLE_CONTENT: [],
            TABLE_ROWS: 0,
        };
    }));
    if (returnResult && events?.onEnd) {
        events.onEnd(result);
    }
    return true;
};
exports.table = {
    list,
    all,
    system,
    schema,
    read,
    select,
    count,
    listToFile,
    exportToFileJSON,
    exportToFileCSV,
    readAllTables,
    exportAllTablesToFileJSON,
    exportAllTablesToFileCSV,
};
